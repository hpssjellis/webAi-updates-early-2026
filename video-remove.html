<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MODNet ‚Äî Live Video Background Removal</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { background: #0a0a0a; color: #eee; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; }
        h1 { color: #00ffcc; margin-bottom: 6px; font-size: 1.4rem; }
        p.sub { color: #555; font-size: 0.8rem; margin-bottom: 20px; }
        .canvases { display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; }
        .panel { text-align: center; }
        .panel span { display: block; font-size: 0.75rem; color: #666; margin-bottom: 6px; }
        video { display: none; }
        canvas { width: 320px; height: 240px; border: 1px solid #333; border-radius: 8px; background: #111; display: block; }
        #myBgCanvas {
            background-image: repeating-conic-gradient(#1a1a1a 0% 25%, #2a2a2a 0% 50%);
            background-size: 16px 16px;
        }
        .controls { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 10px 24px; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        #myLoadBtn      { background: #00ffcc; color: #000; }
        #myStartBtn     { background: #ff0077; color: #fff; }
        #myStopBtn      { background: #333;    color: #eee; }
        #myRecordBtn    { background: #ff6600; color: #fff; }
        #myStopRecBtn   { background: #333;    color: #eee; }
        #myStatus { margin-top: 14px; font-family: monospace; font-size: 0.78rem; color: #666; text-align: center; max-width: 500px; }
        #myDownloadArea { margin-top: 14px; }
        #myDownloadArea a { color: #00ffcc; font-size: 0.85rem; text-decoration: none; border: 1px solid #00ffcc; padding: 8px 18px; border-radius: 6px; }
        #myDownloadArea a:hover { background: #00ffcc22; }
    </style>
</head>
<body>

    <h1>‚ú¶ MODNet ‚Äî Live Video BG Removal</h1>
    <p class="sub">WebGPU ¬∑ Runs 100% locally ¬∑ No data leaves your device</p>

    <div class="canvases">
        <div class="panel"><span>Camera Feed</span><canvas id="mySrcCanvas"></canvas></div>
        <div class="panel"><span>Background Removed</span><canvas id="myBgCanvas"></canvas></div>
    </div>

    <video id="myVideo" autoplay playsinline muted></video>

    <div class="controls">
        <button id="myLoadBtn">‚ö° Load MODNet</button>
        <button id="myStartBtn"   disabled>‚ñ∂ Start</button>
        <button id="myStopBtn"    disabled>‚èπ Stop</button>
        <button id="myRecordBtn"  disabled>‚è∫ Record</button>
        <button id="myStopRecBtn" disabled>‚èπ Stop Recording</button>
    </div>

    <div id="myDownloadArea"></div>
    <div id="myStatus">Requesting camera...</div>

    <script type="module">
        import { AutoModel, AutoProcessor, RawImage, env }
            from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@4.0.0-next.4";

        env.allowLocalModels = false;

        // ‚îÄ‚îÄ DOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const myVideo      = document.getElementById('myVideo');
        const mySrcCanvas  = document.getElementById('mySrcCanvas');
        const myBgCanvas   = document.getElementById('myBgCanvas');
        const mySrcCtx     = mySrcCanvas.getContext('2d', { willReadFrequently: true });
        const myBgCtx      = myBgCanvas.getContext('2d',  { willReadFrequently: true });
        const myStatus     = document.getElementById('myStatus');
        const myLoadBtn    = document.getElementById('myLoadBtn');
        const myStartBtn   = document.getElementById('myStartBtn');
        const myStopBtn    = document.getElementById('myStopBtn');
        const myRecordBtn  = document.getElementById('myRecordBtn');
        const myStopRecBtn = document.getElementById('myStopRecBtn');
        const myDlArea     = document.getElementById('myDownloadArea');

        // ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let myModel     = null;
        let myProcessor = null;
        let myRunning   = false;
        let myRecorder  = null;
        let myChunks    = [];

        // ‚îÄ‚îÄ Camera: start immediately on page load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        (async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                myVideo.srcObject = stream;
                await new Promise(r => myVideo.onloadedmetadata = () => {
                    const W = myVideo.videoWidth  || 640;
                    const H = myVideo.videoHeight || 480;
                    mySrcCanvas.width  = myBgCanvas.width  = W;
                    mySrcCanvas.height = myBgCanvas.height = H;
                    r();
                });
                // Mirror the source preview to match what the user expects from a selfie cam
                mySrcCtx.translate(mySrcCanvas.width, 0);
                mySrcCtx.scale(-1, 1);

                myStatus.textContent = 'Camera ready. Click "Load MODNet" to begin.';
                myLoadBtn.disabled = false;

                // Draw the live camera feed to mySrcCanvas so user can see themselves
                function myDrawPreview() {
                    mySrcCtx.drawImage(myVideo, 0, 0, mySrcCanvas.width, mySrcCanvas.height);
                    requestAnimationFrame(myDrawPreview);
                }
                myDrawPreview();

            } catch (e) {
                myStatus.textContent = '‚ùå Camera denied: ' + e.message;
            }
        })();

        // ‚îÄ‚îÄ Model load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        myLoadBtn.onclick = async () => {
            myLoadBtn.disabled = true;
            myStatus.textContent = '‚è≥ Loading MODNet...';
            console.log('[MODNet] Loading model...');

            try {
                myModel = await AutoModel.from_pretrained('Xenova/modnet', {
                    device: 'webgpu',
                    dtype: 'fp32',
                    progress_callback: (p) => {
                        if (p.status === 'initiate') {
                            myStatus.textContent = `Fetching: ${p.file}`;
                        } else if (p.status === 'progress' && p.total) {
                            const pct = Math.round(p.progress);
                            const mb  = (p.loaded / 1024 / 1024).toFixed(1);
                            const tot = (p.total  / 1024 / 1024).toFixed(1);
                            myStatus.textContent = `‚Üì ${p.file}  ${mb} / ${tot} MB  (${pct}%)`;
                        } else if (p.status === 'done') {
                            myStatus.textContent = `‚úî Loaded: ${p.file}`;
                        } else if (p.status === 'ready') {
                            console.log('[MODNet] Model ready.');
                        }
                    },
                });

                myProcessor = await AutoProcessor.from_pretrained('Xenova/modnet');

                myStatus.textContent = 'üü¢ Ready ‚Äî press Start!';
                myStartBtn.disabled = false;
                myLoadBtn.style.display = 'none';

            } catch (e) {
                myStatus.textContent = '‚ùå Load failed: ' + e.message;
                console.error('[MODNet]', e);
                myLoadBtn.disabled = false;
            }
        };

        // ‚îÄ‚îÄ Inference loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function myLoop() {
            if (!myRunning) return;

            // Snapshot the (already-mirrored) source canvas
            try {
                const myFrame = await RawImage.fromCanvas(mySrcCanvas);
                const { pixel_values } = await myProcessor(myFrame);
                const { output } = await myModel({ input: pixel_values });

                const myMask = await RawImage
                    .fromTensor(output[0].mul(255).to('uint8'))
                    .resize(mySrcCanvas.width, mySrcCanvas.height);

                // Draw source frame then punch out the background via alpha mask
                myBgCtx.clearRect(0, 0, myBgCanvas.width, myBgCanvas.height);
                myBgCtx.drawImage(mySrcCanvas, 0, 0);

                const myFrameData = myBgCtx.getImageData(0, 0, myBgCanvas.width, myBgCanvas.height);
                const myPixels    = myFrameData.data;
                const myMaskData  = myMask.data;

                for (let i = 0; i < myMaskData.length; i++) {
                    myPixels[i * 4 + 3] = myMaskData[i];
                }
                myBgCtx.putImageData(myFrameData, 0, 0);

                myStatus.textContent = 'üü¢ Running ‚Äî WebGPU active';

            } catch (e) {
                console.error('[MODNet] Frame error:', e);
                myStatus.textContent = '‚ö†Ô∏è Frame error ‚Äî retrying...';
            }

            setTimeout(myLoop, 0);
        }

        // ‚îÄ‚îÄ Inference controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        myStartBtn.onclick = () => {
            myRunning = true;
            myStartBtn.disabled  = true;
            myStopBtn.disabled   = false;
            myRecordBtn.disabled = false;
            myLoop();
        };

        myStopBtn.onclick = () => {
            myRunning = false;
            myStartBtn.disabled  = false;
            myStopBtn.disabled   = true;
            myRecordBtn.disabled = true;
            // Stop recording too if active
            if (myRecorder && myRecorder.state === 'recording') myStopRecBtn.click();
            myStatus.textContent = '‚è∏ Paused.';
        };

        // ‚îÄ‚îÄ Recording: capture the output (bg-removed) canvas as WebM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        myRecordBtn.onclick = () => {
            myChunks = [];
            myDlArea.innerHTML = '';

            // captureStream() taps directly into the canvas rendering pipeline
            const myStream = myBgCanvas.captureStream(30); // 30fps target
            myRecorder = new MediaRecorder(myStream, {
                mimeType: MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
                    ? 'video/webm;codecs=vp9'
                    : 'video/webm',
            });

            myRecorder.ondataavailable = e => {
                if (e.data.size > 0) myChunks.push(e.data);
            };

            myRecorder.onstop = () => {
                const myBlob    = new Blob(myChunks, { type: 'video/webm' });
                const myUrl     = URL.createObjectURL(myBlob);
                const myAnchor  = document.createElement('a');
                myAnchor.href      = myUrl;
                myAnchor.download  = `modnet-${Date.now()}.webm`;
                myAnchor.textContent = '‚¨áÔ∏è Download Recorded Video (.webm)';
                myDlArea.innerHTML = '';
                myDlArea.appendChild(myAnchor);
                myStatus.textContent = '‚úÖ Recording saved ‚Äî click the link to download.';
            };

            myRecorder.start();
            myRecordBtn.disabled  = true;
            myStopRecBtn.disabled = false;
            myStatus.textContent  = '‚è∫ Recording...';
        };

        myStopRecBtn.onclick = () => {
            if (myRecorder && myRecorder.state === 'recording') myRecorder.stop();
            myRecordBtn.disabled  = false;
            myStopRecBtn.disabled = true;
        };
    </script>
</body>
</html>
