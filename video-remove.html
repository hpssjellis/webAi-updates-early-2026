<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MODNet ‚Äî Live Video Background Removal</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { background: #0a0a0a; color: #eee; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; }
        h1 { color: #00ffcc; margin-bottom: 6px; font-size: 1.4rem; }
        p.sub { color: #555; font-size: 0.8rem; margin-bottom: 20px; }

        .canvases { display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; }
        .panel { text-align: center; }
        .panel span { display: block; font-size: 0.75rem; color: #666; margin-bottom: 6px; }

        /* The source video is hidden ‚Äî we only use it as a pixel source */
        video { display: none; }

        canvas {
            width: 320px;
            height: 240px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #111;
            display: block;
        }
        #myBgCanvas {
            /* Checkerboard to show transparency */
            background-image: repeating-conic-gradient(#1a1a1a 0% 25%, #2a2a2a 0% 50%);
            background-size: 16px 16px;
        }

        .controls { margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 10px 24px; font-weight: bold; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        #myLoadBtn  { background: #00ffcc; color: #000; }
        #myStartBtn { background: #ff0077; color: #fff; }
        #myStopBtn  { background: #333;    color: #eee; }

        #myStatus { margin-top: 14px; font-family: monospace; font-size: 0.78rem; color: #666; text-align: center; max-width: 500px; }
    </style>
</head>
<body>

    <h1>‚ú¶ MODNet ‚Äî Live Video BG Removal</h1>
    <p class="sub">WebGPU ¬∑ Runs 100% locally ¬∑ No data leaves your device</p>

    <div class="canvases">
        <div class="panel"><span>Camera Feed</span><canvas id="mySrcCanvas"></canvas></div>
        <div class="panel"><span>Background Removed</span><canvas id="myBgCanvas"></canvas></div>
    </div>

    <!-- Hidden video element ‚Äî pixel source only -->
    <video id="myVideo" autoplay playsinline muted></video>

    <div class="controls">
        <button id="myLoadBtn">‚ö° Load MODNet</button>
        <button id="myStartBtn" disabled>‚ñ∂ Start</button>
        <button id="myStopBtn"  disabled>‚èπ Stop</button>
    </div>

    <div id="myStatus">Click "Load MODNet" to download the model (~14MB).</div>

    <script type="module">
        import {
            AutoModel,
            AutoProcessor,
            RawImage,
            env,
        } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers@4.0.0-next.4";

        env.allowLocalModels = false;

        // ‚îÄ‚îÄ DOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const myVideo     = document.getElementById('myVideo');
        const mySrcCanvas = document.getElementById('mySrcCanvas');
        const myBgCanvas  = document.getElementById('myBgCanvas');
        const mySrcCtx    = mySrcCanvas.getContext('2d', { willReadFrequently: true });
        const myBgCtx     = myBgCanvas.getContext('2d',  { willReadFrequently: true });
        const myStatus    = document.getElementById('myStatus');
        const myLoadBtn   = document.getElementById('myLoadBtn');
        const myStartBtn  = document.getElementById('myStartBtn');
        const myStopBtn   = document.getElementById('myStopBtn');

        // ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let myModel     = null;
        let myProcessor = null;
        let myRunning   = false;

        // ‚îÄ‚îÄ Camera setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function myStartCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480, facingMode: 'user' }
            });
            myVideo.srcObject = stream;
            await new Promise(r => myVideo.onloadedmetadata = () => {
                // Size both canvases to the actual video dimensions
                const W = myVideo.videoWidth  || 640;
                const H = myVideo.videoHeight || 480;
                mySrcCanvas.width  = myBgCanvas.width  = W;
                mySrcCanvas.height = myBgCanvas.height = H;
                r();
            });
        }

        // ‚îÄ‚îÄ Model load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        myLoadBtn.onclick = async () => {
            myLoadBtn.disabled = true;
            myStatus.textContent = '‚è≥ Starting camera...';
            try {
                await myStartCamera();
            } catch (e) {
                myStatus.textContent = '‚ùå Camera denied: ' + e.message;
                myLoadBtn.disabled = false;
                return;
            }

            myStatus.textContent = '‚è≥ Loading MODNet...';
            console.log('[MODNet] Loading model...');

            try {
                // MODNet uses AutoModel + AutoProcessor directly ‚Äî there is no
                // 'background-removal' pipeline wrapper for this model.
                // dtype: 'fp32' is required ‚Äî fp16 produces corrupt output on WebGPU.
                myModel = await AutoModel.from_pretrained('Xenova/modnet', {
                    device: 'webgpu',
                    dtype: 'fp32',
                    progress_callback: (p) => {
                        if (p.status === 'initiate') {
                            myStatus.textContent = `Fetching: ${p.file}`;
                            console.log('[MODNet] Fetching:', p.file);
                        } else if (p.status === 'progress' && p.total) {
                            const pct = Math.round(p.progress);
                            const mb  = (p.loaded / 1024 / 1024).toFixed(1);
                            const tot = (p.total  / 1024 / 1024).toFixed(1);
                            myStatus.textContent = `‚Üì ${p.file}  ${mb} / ${tot} MB  (${pct}%)`;
                        } else if (p.status === 'done') {
                            myStatus.textContent = `‚úî Loaded: ${p.file}`;
                            console.log('[MODNet] Loaded:', p.file);
                        } else if (p.status === 'ready') {
                            console.log('[MODNet] Model ready.');
                        }
                    },
                });

                myProcessor = await AutoProcessor.from_pretrained('Xenova/modnet');

                myStatus.textContent = 'üü¢ Ready ‚Äî press Start!';
                myStartBtn.disabled = false;
                myLoadBtn.style.display = 'none';

            } catch (e) {
                myStatus.textContent = '‚ùå Load failed: ' + e.message;
                console.error('[MODNet] Load error:', e);
                myLoadBtn.disabled = false;
            }
        };

        // ‚îÄ‚îÄ Inference loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function myLoop() {
            if (!myRunning) return;

            // 1. Draw current video frame to the source preview canvas
            mySrcCtx.drawImage(myVideo, 0, 0, mySrcCanvas.width, mySrcCanvas.height);

            try {
                // 2. Wrap the canvas as a RawImage for the processor
                const myFrame = await RawImage.fromCanvas(mySrcCanvas);

                // 3. Pre-process: resize + normalise to the tensor MODNet expects
                const { pixel_values } = await myProcessor(myFrame);

                // 4. Run model ‚Äî input key is 'input', output key is 'output'
                const { output } = await myModel({ input: pixel_values });

                // 5. Convert the float [0-1] alpha mask to uint8 [0-255],
                //    then resize it back up to the original frame dimensions.
                const myMask = await RawImage
                    .fromTensor(output[0].mul(255).to('uint8'))
                    .resize(mySrcCanvas.width, mySrcCanvas.height);

                // 6. Composite: draw original frame, then apply the mask as alpha.
                //    We use 'destination-in' so only pixels where mask=white survive.
                myBgCtx.clearRect(0, 0, myBgCanvas.width, myBgCanvas.height);
                myBgCtx.drawImage(mySrcCanvas, 0, 0);

                // Build an ImageData from the mask (grayscale ‚Üí RGBA alpha channel)
                const myMaskData  = myMask.data;               // Uint8Array, 1 channel
                const myFrameData = myBgCtx.getImageData(
                    0, 0, myBgCanvas.width, myBgCanvas.height
                );
                const myPixels = myFrameData.data;              // RGBA Uint8ClampedArray

                // Write the mask value into the alpha channel of every pixel
                for (let i = 0; i < myMaskData.length; i++) {
                    myPixels[i * 4 + 3] = myMaskData[i];
                }
                myBgCtx.putImageData(myFrameData, 0, 0);

                myStatus.textContent = 'üü¢ Running ‚Äî WebGPU active';

            } catch (e) {
                console.error('[MODNet] Frame error:', e);
                myStatus.textContent = '‚ö†Ô∏è Frame error ‚Äî retrying...';
            }

            // Tail-schedule: next frame only starts after this one fully completes
            setTimeout(myLoop, 0);
        }

        // ‚îÄ‚îÄ Controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        myStartBtn.onclick = () => {
            myRunning = true;
            myStartBtn.disabled = true;
            myStopBtn.disabled  = false;
            myLoop();
        };

        myStopBtn.onclick = () => {
            myRunning = false;
            myStartBtn.disabled = false;
            myStopBtn.disabled  = true;
            myStatus.textContent = '‚è∏ Paused.';
        };
    </script>
</body>
</html>
