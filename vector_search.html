<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Student Vector Search (v4)</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; background: #fdfdfd; }
        #myContainer { max-width: 500px; margin: auto; background: white; padding: 20px; border-radius: 10px; border: 1px solid #ddd; }
        input { width: 80%; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: 5px; }
        .myResultItem { text-align: left; padding: 8px; border-bottom: 1px solid #eee; }
        .myScore { float: right; color: #888; font-size: 0.8em; }
    </style>
</head>
<body>

<div id="myContainer">
    <h2>Semantic Search (Transformers.js v4)</h2>
    <p>Try searching for “yellow fruit” or “healthy snack”</p>
    
    <input type="text" id="myQueryInput" placeholder="Type your search here..." 
           onkeyup="if(event.key==='Enter') myPerformSearch()">
    <button onclick="myPerformSearch()">Search Meaning</button>
    
    <div id="myStatus" style="margin-top:10px; font-size: 0.9em; color: blue;">Model ready.</div>
    <div id="myResultsList"></div>
</div>

<script type="module">
    import { pipeline, cos_sim } from "https://cdn.jsdelivr.net/npm/@huggingface/transformers";

    const myData = [
        "A sweet yellow banana",
        "A crunchy red apple",
        "A fast blue sports car",
        "A loyal golden retriever dog",
        "A bowl of healthy green salad",
        "A warm cup of coffee"
    ];

    let myExtractor;
    let myDatabaseEmbeddings = [];

    async function myInitVectorSearch() {
        const myStatus = document.getElementById('myStatus');
        myStatus.innerText = "Loading MiniLM (v4)...";

        // Load pipeline
        myExtractor = await pipeline(
            "feature-extraction",
            "Xenova/all-MiniLM-L6-v2"
        );

        myStatus.innerText = "Indexing database...";

        for (const text of myData) {
            const output = await myExtractor(text, {
                pooling: "mean",
                normalize: true
            });

            // v4 returns nested arrays → flatten
            const vector = new Float32Array(output[0].data);

            myDatabaseEmbeddings.push({ text, vector });
        }

        myStatus.innerText = "Ready to search!";
    }

    async function myPerformSearch() {
        const myQuery = document.getElementById('myQueryInput').value;
        const myResultsDiv = document.getElementById('myResultsList');
        if (!myQuery) return;

        myResultsDiv.innerHTML = "<div>Searching...</div>";

        const output = await myExtractor(myQuery, {
            pooling: "mean",
            normalize: true
        });

        const queryVector = new Float32Array(output[0].data);

        const scored = myDatabaseEmbeddings
            .map(item => ({
                text: item.text,
                score: cos_sim(queryVector, item.vector)
            }))
            .sort((a, b) => b.score - a.score);

        myResultsDiv.innerHTML = "";
        scored.slice(0, 3).forEach(res => {
            myResultsDiv.innerHTML += `
                <div class="myResultItem">
                    ${res.text}
                    <span class="myScore">${(res.score * 100).toFixed(1)}% match</span>
                </div>`;
        });
    }

    window.myPerformSearch = myPerformSearch;
    myInitVectorSearch();
</script>

</body>
</html>
